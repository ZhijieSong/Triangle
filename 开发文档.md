# 一次渲染流程
    1. 创建 TrContext 唯一实例。
    2. 创建 TrShader（允许多个）。
    3. 创建 TrRenderPipeline 并提供该管线使用的所有描述符（允许多个）。
    4. 创建 TrBuffer、TrTexture（允许多个）。
    5. 创建 TrFrameBuffer（允许多个）。
    6. 创建 TrRenderPass（允许多个）。
    7. 主窗体根据 TrRenderPass 的 DescriptorType 进行排序，然后依次进行渲染。
        - 绑定对应 TrBuffer、TrTexture、TrFrameBuffer 并写入数据。
        - 依次渲染 TrRenderPipeline。
    8. 释放资源。

# 注意事项

## Core 项目中应该遵循以下规范：
    Graphics 文件夹中的类尽量保持只读属性。  
    如存在需要修改的属性，请不要影响到其他属性或方法。  

    例如 TrPipeline 中存在各种 Is...Test、Is...Write 等属性。
    ```csharp
    public bool Is...Test { get; set; } = true;

    public bool Is...Write { get; set; } = true;
    ```
    根据 OpenGL 的特性，每次切换到不同的渲染管线时其状态不会被重置，所以需要重新设置。 

    例如在切换到 TrRenderPipeline 时，需要将 Is...Test、Is...Write 等属性设置为 true。  

# 接下来要完成的工作
    - [ ] 1. 完善 TrBuffer
    - [ ] 2. 完善 TrTexture
    - [ ] 3. 开发 TrFrameBuffer
    - [ ] 4. TrPipeline 中的描述符写入数据和与 TrBuffer 的绑定。

# 需要确定的事项
    1. 是否添加 TrMaterial 类。

# 未来
    1. 抽象接口，实现多种渲染管线。
    2. 实现计算管线。